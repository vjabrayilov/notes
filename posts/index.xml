<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Vahab Jabrayilov's Blog</title><link>https://vjabrayilov.github.io/notes/posts/</link><description>Recent content in Posts on Vahab Jabrayilov's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Sep 2022 10:03:50 +0400</lastBuildDate><atom:link href="https://vjabrayilov.github.io/notes/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>GSoC Final Submission Thanos</title><link>https://vjabrayilov.github.io/notes/posts/gsoc/</link><pubDate>Thu, 08 Sep 2022 10:03:50 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/gsoc/</guid><description>Overview The main goal was to support on the fly compaction of TSDB blocks without using any disk space or constant amount of the disk space. As analyzing, I came across with the following challenges:
TSDB blocks have a special structure and the main challenge stems from already big size of a single block. compactor module is written such that it operates on the already downloaded blocks, so nothing to be done here.</description></item><item><title>Go Serverless: Securing Cloud via Serverless Design Patterns HotCloud'18</title><link>https://vjabrayilov.github.io/notes/posts/serverlessdesignpatterns/</link><pubDate>Tue, 06 Sep 2022 15:17:43 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/serverlessdesignpatterns/</guid><description>Review Authors have a security background and paper aims at utilizing serverless design patterns in security applications. They solely focus on AWS Lambda, and assume that all the responsibility to secure lambda execution lies on the cloud provider. However, customers are also responsible to secure their communication. They briefly describe six design patterns and how one can use them to develop a security oriented application.
Periodic Invocation Pattern represents the kind of models that invoke lambda functions periodically by using schedulers.</description></item><item><title>Granular Computing HotOS'19</title><link>https://vjabrayilov.github.io/notes/posts/granularcomputing/</link><pubDate>Tue, 06 Sep 2022 12:45:51 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/granularcomputing/</guid><description>Review This paper is by the group of John Ousterhout and introduces the concept of so called “Granular computing”. They define “Granular computing” as the collection of very short-lived (10-100 usecs) tasks. The other main properties are large scale(1k-1M cooperating tasks) and short bursts(1-10 msecs of activity). Authors discuss the challenges coming with the new concept and present a few initial ideas about the required infrastructure to support it.
In granular computing, applications are composed of a very large number of small tasks running in microsecond scale both in parallel and sequentially, spread across thousands of machines.</description></item><item><title>Will Serverless End the Dominance of Linux in the Cloud? HotOS’17</title><link>https://vjabrayilov.github.io/notes/posts/endoflinux/</link><pubDate>Mon, 05 Sep 2022 12:31:36 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/endoflinux/</guid><description>Review It’s a very short read and one of the early works. The main topic of discussion is the shortcomings of the Linux kernel for the current serverless paradigm. They argue that native container abstraction is ill-suited to be run as a unit of execution for serverless. They show that bypassing the kernel with unikernels can yield at least a factor of 6 better latency and throughput. While the unit of execution in the cloud shrinks, the complexity of the kernel is growing.</description></item><item><title>Mencius: Building Efficient Replicated State Machines for WANs</title><link>https://vjabrayilov.github.io/notes/posts/mencius/</link><pubDate>Tue, 26 Jul 2022 11:39:00 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/mencius/</guid><description>Problem Solution Contributions Discussion of Evaluations Notes References Problem Paxos relies on a single leader to choose the request sequence which is a bottleneck limiting the throughput(Computational bottleneck at the leader). Moreover, having a single leader leads to an unbalanced communication pattern limiting the full utilization of bandwidth(Unbalanced communication pattern). The leader always learn and commits the value it proposed, but it takes time for non-leader nodes to learn the committed value resulting in higher learning latency for non-leader servers.</description></item><item><title>Firecracker: Lightweight Virtualization for Serverless Applications</title><link>https://vjabrayilov.github.io/notes/posts/firecracker/</link><pubDate>Thu, 21 Jul 2022 10:42:00 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/firecracker/</guid><description>Summary Background Virtualization Lambda Interesting points References Summary Firecracker is a high-performance virtualization solution built to run Amazon’s serverless applications securely and with minimal resources. It now does so at immense scale. Background Virtualization Initially, a separate VM per Lambda customer, but existing VM solutions required significant resources, hence resulting in non-optimal utilization. 2 types of hypervisors Type 1 directly integrated in the hardware Type 2 run an operating system on top of the hardware, then run the hypervisor on top of that operating system Linux has a hypervisor built into the kernel - Kernel Virtual Machine, arguably a Type 1 hypervisor.</description></item><item><title>Serverless Computing</title><link>https://vjabrayilov.github.io/notes/posts/riseofserverless/</link><pubDate>Tue, 19 Jul 2022 14:59:06 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/riseofserverless/</guid><description>Introduction Serverless computing delivers true pay only for resources used with almost infinite scalability. Customers will only focus on the business aspects of their applications. Developers do not need to to worry about low-level details of servers management and scaling, and only pay for when processing requests or events. Definiton: Serverless computing is a platform that hides server usage from developers and runs code on-demand automatically scaled and billed only for the time the code is running.</description></item><item><title>How to Read a Paper</title><link>https://vjabrayilov.github.io/notes/posts/howtoreadapaper/</link><pubDate>Tue, 19 Jul 2022 14:22:02 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/howtoreadapaper/</guid><description>Key idea: read the paper in up to 3 passes 1st pass gives the general idea 5-10 mins get a bird&amp;rsquo;s-eye view and decide whether to do any more passes or not Do the following carefully read the title, abstract and introduction read the section and sub-section headings, but ignore everything else read the conclusions glance over the references, mentally ticking off the already read ones at the end of this pass, five Cs should be answered Category: What type of paper is this?</description></item><item><title>Stoppable Paxos</title><link>https://vjabrayilov.github.io/notes/posts/stoppablepaxos/</link><pubDate>Tue, 19 Jul 2022 10:17:24 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/stoppablepaxos/</guid><description>Summary Stoppable state machines are used to implement reconfiguration, simply a reconfigurable state machine consists of several stoppable state machines. To switch between the configurations, one is stopped and the other is started.
Traditionally, reconfiguration is done by executing special reconfiguration commands as a consensus instance. However, it prevents the concurrent execution of other commands until the new configuration is selected and ready. The main purpose of the Stoppable Paxos is to address this bottleneck.</description></item><item><title>Metastable Failures in Distributed Systems</title><link>https://vjabrayilov.github.io/notes/posts/metastablefailuresindistrsys/</link><pubDate>Mon, 18 Jul 2022 16:42:42 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/metastablefailuresindistrsys/</guid><description>Introduction Interestingly, most features improving the efficiency or reliability are the main cause of metastable failures. Trigger causes the open system (with an unctrolled source of load) to enter a bad state persisting even after the removal of the trigger. Failures that are resolved when the trigger is removed are not metastable. Recovery requires a strong corrective push, e.g. rebooting or dramatically reducing the load. Lifecycle of a metastable failure: load rises trigger stable state ------------&amp;gt; vulnerable state --------&amp;gt; metastable state (still healthy) the vulnerable state is not an overloaded state; system can run for a long time here; but can get stuck in metastable state w/o any increase in the load.</description></item><item><title>Levels Of Techie Enlightenment</title><link>https://vjabrayilov.github.io/notes/posts/levelsoftechieenlightenment/</link><pubDate>Mon, 18 Jul 2022 16:06:24 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/levelsoftechieenlightenment/</guid><description>3 levels of enlightenment:
Level 0: The Newcomer a ton of materials to master reaction: Overwhelmed problem: lack of breadth Level 1: The Half-Expert weakness finding machines reaction: dismissal and destruction Level 2: Chaotic times &amp;hellip; Level 3: Nirvana people are able to provide and receive criticism without making it personal far more productive References https://hackingdistributed.com/2017/05/04/stages-of-enlightenment/</description></item><item><title>Kafka vs RabbitMQ</title><link>https://vjabrayilov.github.io/notes/posts/kafkavsrabbit/</link><pubDate>Mon, 18 Jul 2022 11:06:00 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/kafkavsrabbit/</guid><description>RabbitMQ Kafka RabbitMQ Architecture Kafka Architecture Use cases References RabbitMQ supports : AMQP : Advanced Message Queuing Protocol MQTT : MQ Telemetry Protocol STOMP : Streaming Text Oriented Messaging Protocol is known as a hybrid broker uses smart broker/dumb consumer model Kafka provides higher throughput, built-in partitioning, replication, and inherent fault-tolerance There are 2 async messagin patterns :
Message Queue
a creating app sends a msg to queue. When the consuming app is ready, it just connects to the queue and retrieves the msg, removing it from the queue.</description></item><item><title>PostToGithub</title><link>https://vjabrayilov.github.io/notes/posts/posttogithub/</link><pubDate>Wed, 13 Jul 2022 17:14:59 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/posttogithub/</guid><description>heading level 1 sample code block : let x = 5 a sample task another sample task but marked A sample table
column 1 column 2 header title</description></item><item><title>First</title><link>https://vjabrayilov.github.io/notes/posts/first/</link><pubDate>Wed, 13 Jul 2022 15:23:19 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/first/</guid><description>First post</description></item><item><title>org-post 1</title><link>https://vjabrayilov.github.io/notes/posts/post1/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/post1/</guid><description>TODO cpp #include&amp;lt;iostream&amp;gt; int main{ std::cout&amp;lt;&amp;lt;&amp;#34;Hello, World!\n&amp;#34;; retirm 0; } java public void main(){ System.out.println(&amp;#34;Hello World&amp;#34;); } heading 2 should be under second header</description></item><item><title>org-post 2</title><link>https://vjabrayilov.github.io/notes/posts/post2/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0400</pubDate><guid>https://vjabrayilov.github.io/notes/posts/post2/</guid><description/></item></channel></rss>